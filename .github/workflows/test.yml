name: Daily Scrum Notification

on:
  schedule:
    # 한국 시간 오전 10시에 실행 (UTC 기준 새벽 1시)
    # 분 시 일 월 요일
    - cron: '0 1 * * *'
  # 수동 실행을 위한 옵션 (Actions 탭에서 직접 실행 가능)
  workflow_dispatch:

jobs:
  notify_discord:
    runs-on: ubuntu-latest
    # 리포지토리 권한 설정 (이슈, PR 읽기)
    permissions:
      issues: read
      pull-requests: read
    steps:
      - name: Checkout repository # 코드 체크아웃
        uses: actions/checkout@v4

      - name: Fetch Open Issues # 열려있는 이슈 목록 가져오기 (최대 30개)
        id: issues
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          issue_list=$(gh issue list --state open --limit 30 --json number,title,url)
          echo "Raw issue list: $issue_list" # 디버깅 로그
          if [[ "$(echo "$issue_list" | jq '. | length')" -gt 0 ]]; then
            # jq -r 로 생성하면 각 항목이 새 줄로 구분된 문자열이 됩니다.
            formatted_issues=$(echo "$issue_list" | jq -r '.[] | "- (#\(.number)) \(.title) - <\(.url)>"')
          else
            formatted_issues="- 열려있는 이슈가 없습니다."
          fi
          echo "Formatted issues (multiline string for GITHUB_ENV):" # 디버깅 로그
          echo "$formatted_issues"
          echo "ISSUE_LIST<<EOF" >> $GITHUB_ENV
          echo "$formatted_issues" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Fetch Open PRs # 열려있는 PR 목록 가져오기 (최대 30개)
        id: prs
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          pr_list=$(gh pr list --state open --limit 30 --json number,title,url)
          echo "Raw PR list: $pr_list" # 디버깅 로그
          if [[ "$(echo "$pr_list" | jq '. | length')" -gt 0 ]]; then
            # jq -r 로 생성하면 각 항목이 새 줄로 구분된 문자열이 됩니다.
            formatted_prs=$(echo "$pr_list" | jq -r '.[] | "- (#\(.number)) \(.title) - <\(.url)>"')
          else
            formatted_prs="- 열려있는 PR이 없습니다."
          fi
          echo "Formatted PRs (multiline string for GITHUB_ENV):" # 디버깅 로그
          echo "$formatted_prs"
          echo "PR_LIST<<EOF" >> $GITHUB_ENV
          echo "$formatted_prs" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Construct Discord Message # Discord 메시지 조합
        id: message
        run: |
          TODAY=$(date +'%Y-%m-%d')

          # GITHUB_ENV에서 읽어온 ISSUE_LIST와 PR_LIST는 여러 줄 문자열입니다.
          # 이 내부의 실제 개행 문자(newline)를 리터럴 '\\n'으로 변경합니다.
          # Bash의 매개변수 확장 기능을 사용합니다: ${parameter//pattern/string}
          # $'\n'은 실제 개행 문자를 의미하며, '\\n'은 리터럴 백슬래시와 n을 의미합니다.
          issues_escaped_for_json="${ISSUE_LIST//$'\n'/\\n}"
          prs_escaped_for_json="${PR_LIST//$'\n'/\\n}"

          # MESSAGE 문자열을 구성할 때, 줄바꿈이 필요한 곳에 리터럴 '\\n'을 사용합니다.
          # 이렇게 해야 MESSAGE 변수 자체가 단일 라인 문자열이 되고, jq가 이를 올바르게 처리할 수 있습니다.
          MESSAGE="## ☀️ ${TODAY} 데일리 스크럼 안내 ☀️\\n\\n"
          MESSAGE+="**⏰ 오늘 오전 데일리 스크럼 시간입니다!**\\n\\n"
          MESSAGE+="**현재 열려있는 이슈:**\\n${issues_escaped_for_json}\\n\\n"
          MESSAGE+="**현재 열려있는 Pull Requests:**\\n${prs_escaped_for_json}\\n\\n"
          MESSAGE+="잠시 하던 일을 멈추고 각자 진행 상황과 이슈를 공유해주세요! 😊"
          
          echo "Constructed Message String (with literal \\\\n for jq):"
          echo "${MESSAGE}" # 이 로그에서는 \\n이 문자 그대로 보일 것입니다.
          echo "---------------------------------"

          # jq를 사용하여 JSON 페이로드 생성
          # --arg 옵션으로 전달된 문자열 내의 '\\n'은 jq에 의해 JSON 문자열 내의 실제 이스케이프된 '\n'으로 올바르게 인코딩됩니다.
          JSON_PAYLOAD=$(jq -nc --arg content "${MESSAGE}" '{"content": $content}')
          
          # JSON 페이로드가 올바르게 생성되었는지 확인 (JSON 문자열 내에 \n이 포함되어야 함)
          printf "Generated JSON_PAYLOAD (this should contain actual \\n for newlines in JSON string):\n%s\n" "${JSON_PAYLOAD}"
          echo "---------------------------------"
          
          # GITHUB_ENV에는 이미 올바른 JSON 문자열이므로 그대로 저장합니다.
          echo "JSON_PAYLOAD=${JSON_PAYLOAD}" >> $GITHUB_ENV

      - name: Send Notification to Discord # Discord로 알림 보내기
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          # JSON_PAYLOAD는 이전 스텝에서 GITHUB_ENV를 통해 전달받음
        run: |
          echo "Attempting to send notification to Discord."
          echo "Using Webhook URL (first 30 chars): $(echo $DISCORD_WEBHOOK_URL | cut -c 1-30)..." # URL 일부만 출력 (보안)
          
          # GITHUB_ENV에서 JSON_PAYLOAD를 읽어옴 (이 스텝에서 직접 접근 시)
          # 만약 이전 스텝에서 설정된 GITHUB_ENV를 바로 사용한다면 이 줄은 필요 없음.
          # current_payload="${JSON_PAYLOAD_FROM_ENV}" # 예시, 실제로는 바로 $JSON_PAYLOAD 사용
          
          echo "Payload being sent (from GITHUB_ENV):"
          printf "%s\n" "$JSON_PAYLOAD" # $JSON_PAYLOAD 변수는 쉘에 의해 이전 스텝의 GITHUB_ENV에서 확장됨
          
          # curl 명령어 실행 및 결과 출력 (오류 확인 용이)
          # -d 옵션에 변수를 사용할 때는 큰따옴표로 감싸서 변수 확장이 일어나도록 합니다.
          curl_response_code=$(curl -s -o /dev/null -w "%{http_code}" -X POST -H "Content-Type: application/json" \
          -d "$JSON_PAYLOAD" \
          "${DISCORD_WEBHOOK_URL}")
          
          echo "Discord API Response Code: $curl_response_code"
          
          if [[ "$curl_response_code" -ge 200 && "$curl_response_code" -lt 300 ]]; then
            echo "Notification sent successfully!"
          else
            echo "Error sending notification. Response code: $curl_response_code"
            # 전체 응답을 보고 싶다면 다음을 활성화
            # curl -i -X POST -H "Content-Type: application/json" -d "$JSON_PAYLOAD" "${DISCORD_WEBHOOK_URL}"
            exit 1 # 실패 시 워크플로우 실패 처리
          fi
